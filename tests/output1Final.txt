KW	data
ID	Term
AO	=
ID	Var
DT	String
BR	|
ID	Cons
DT	String
KW	deriving
LB	(
FR	Show
FA	,
FR	Eq
RB	)
KW	type
ID	Substitution
AO	=
LB	(
ID	Term
FA	,
ID	Term
RB	)
KW	data
ID	Solution
AO	=
ID	No
BR	|
ID	Yes
LS	[
ID	Substitution
RS	]
KW	deriving
LB	(
FR	Show
FA	,
FR	Eq
RB	)
KW	data
ID	Predicate
AO	=
ID	P
DT	String
LS	[
ID	Term
RS	]
KW	deriving
FR	Show
KW	type
ID	Goals
AO	=
LS	[
ID	Predicate
RS	]
KW	type
ID	Rule
AO	=
LB	(
ID	Predicate
FA	,
ID	Goals
RB	)
KW	type
ID	KB
AO	=
LS	[
ID	Rule
RS	]
ID	unifyTerms
HT	::
ID	Term
AR	->
ID	Term
AR	->
ID	Solution
AR	->
ID	Solution
ID	unifyTerms
LB	(
ID	Cons
ID	c1
RB	)
LB	(
ID	Cons
ID	c2
RB	)
ID	sol
AO	=
KW	if
ID	c1
EQ	==
ID	c2
KW	then
ID	sol
KW	else
ID	No
ID	unifyTerms
LB	(
ID	Var
ID	v1
RB	)
LB	(
ID	Var
ID	v2
RB	)
LB	(
ID	Yes
ID	subList
RB	)
AO	=
ID	Yes
LB	(
ID	subList
CN	++
LS	[
LB	(
ID	Var
ID	v2
FA	,
ID	Var
ID	v1
RB	)
RS	]
RB	)
ID	unifyTerms
LB	(
ID	Cons
ID	c
RB	)
LB	(
ID	Var
ID	v
RB	)
ID	sol
AO	=
ID	unifyTerms
LB	(
ID	Var
ID	v
RB	)
LB	(
ID	Cons
ID	c
RB	)
ID	sol
ID	unifyTerms
LB	(
ID	Var
ID	v
RB	)
LB	(
ID	Cons
ID	c
RB	)
LB	(
ID	Yes
ID	subList
RB	)
AO	=
KW	if
ID	isFree
LB	(
ID	Var
ID	v
RB	)
LB	(
ID	Yes
ID	subList
RB	)
KW	then
ID	Yes
LB	(
ID	subList
CN	++
LS	[
LB	(
ID	Var
ID	v
FA	,
ID	Cons
ID	c
RB	)
RS	]
RB	)
KW	else
KW	if
ID	getCurVal
LB	(
ID	Var
ID	v
RB	)
LB	(
ID	Yes
ID	subList
RB	)
EQ	==
LB	(
ID	Cons
ID	c
RB	)
KW	then
LB	(
ID	Yes
ID	subList
RB	)
KW	else
ID	No
ID	isFree
HT	::
ID	Term
AR	->
ID	Solution
AR	->
DT	Bool
ID	isFree
LB	(
ID	Var
ID	v
RB	)
LB	(
ID	Yes
ID	subList
RB	)
AO	=
ID	notElem
LB	(
ID	Var
ID	v
RB	)
ID	boundVars
KW	where
ID	boundVars
AO	=
ID	map
ID	fst
ID	subList
ID	getCurVal
HT	::
ID	Term
AR	->
ID	Solution
AR	->
ID	Term
ID	getCurVal
LB	(
ID	Var
ID	v
RB	)
LB	(
ID	Yes
LB	(
LB	(
ID	x
FA	,
ID	y
RB	)
CL	:
ID	tail
RB	)
RB	)
AO	=
KW	if
LB	(
ID	Var
ID	v
RB	)
EQ	==
ID	x
KW	then
ID	y
KW	else
ID	getCurVal
LB	(
ID	Var
ID	v
RB	)
LB	(
ID	Yes
ID	tail
RB	)
ID	unifyWithHead
HT	::
ID	Predicate
AR	->
ID	Predicate
AR	->
ID	Solution
AR	->
ID	Solution
ID	unifyWithHead
LB	(
ID	P
ID	name1
ID	args1
RB	)
LB	(
ID	P
ID	name2
ID	args2
RB	)
ID	sol
AO	=
KW	if
ID	name1
EQ	==
ID	name2
KW	then
ID	unifyArgs
ID	args1
ID	args2
ID	sol
KW	else
ID	No
ID	unifyArgs
HT	::
LS	[
ID	Term
RS	]
AR	->
LS	[
ID	Term
RS	]
AR	->
ID	Solution
AR	->
ID	Solution
ID	unifyArgs
EL	[]
EL	[]
ID	sol
AO	=
ID	sol
ID	unifyArgs
EL	[]
WC	_
WC	_
AO	=
ID	No
ID	unifyArgs
WC	_
EL	[]
WC	_
AO	=
ID	No
ID	unifyArgs
LB	(
ID	x
CL	:
ID	xs
RB	)
LB	(
ID	y
CL	:
ID	ys
RB	)
ID	sol
AO	=
KW	if
ID	tmpSol
EQ	==
ID	No
KW	then
ID	No
KW	else
ID	unifyArgs
ID	xs
ID	ys
ID	tmpSol
KW	where
ID	tmpSol
AO	=
ID	unifyTerms
ID	x
ID	y
ID	sol
ID	applySub
HT	::
ID	Substitution
AR	->
ID	Predicate
AR	->
ID	Predicate
ID	applySub
ID	sub
LB	(
ID	P
ID	name
ID	args
RB	)
AO	=
ID	P
ID	name
LB	(
ID	replace
ID	args
ID	sub
RB	)
ID	replace
HT	::
LS	[
ID	Term
RS	]
AR	->
ID	Substitution
AR	->
LS	[
ID	Term
RS	]
ID	replace
EL	[]
WC	_
AO	=
EL	[]
ID	replace
LB	(
ID	x
CL	:
ID	xs
RB	)
LB	(
ID	old
FA	,
ID	new
RB	)
AO	=
KW	if
ID	old
EQ	==
ID	x
KW	then
ID	new
CL	:
ID	replace
ID	xs
LB	(
ID	old
FA	,
ID	new
RB	)
KW	else
ID	x
CL	:
ID	replace
ID	xs
LB	(
ID	old
FA	,
ID	new
RB	)
ID	applySubBody
HT	::
ID	Substitution
AR	->
ID	Goals
AR	->
ID	Goals
ID	applySubBody
ID	s
ID	g
AO	=
ID	map
LB	(
ID	applySub
ID	s
RB	)
ID	g
ID	applySolSubBody
HT	::
ID	Solution
AR	->
ID	Goals
AR	->
ID	Goals
ID	applySolSubBody
LB	(
ID	Yes
ID	subList
RB	)
ID	body
AO	=
ID	foldr
ID	applySubBody
ID	body
ID	subList
ID	filterTmpVars
HT	::
LS	[
ID	Substitution
RS	]
AR	->
LS	[
ID	Substitution
RS	]
ID	filterTmpVars
EL	[]
AO	=
EL	[]
ID	filterTmpVars
LB	(
LB	(
ID	Var
ID	v
FA	,
ID	new
RB	)
CL	:
ID	xs
RB	)
AO	=
KW	if
ID	v
GE	>=
ST	"M"
KW	then
ID	filterTmpVars
ID	xs
KW	else
LB	(
ID	Var
ID	v
FA	,
ID	new
RB	)
CL	:
ID	filterTmpVars
ID	xs
ID	allSolutions
HT	::
ID	Predicate
AR	->
ID	KB
AR	->
LS	[
ID	Solution
RS	]
ID	allSolutions
ID	p
ID	kb
AO	=
ID	allSol
ID	p
ID	kb
ID	kb
LB	(
ID	Yes
EL	[]
RB	)
ID	allSol
HT	::
ID	Predicate
AR	->
ID	KB
AR	->
ID	KB
AR	->
ID	Solution
AR	->
LS	[
ID	Solution
RS	]
ID	allSol
ID	p
EL	[]
ID	original
ID	s
AO	=
EL	[]
ID	allSol
ID	p
LB	(
ID	r
CL	:
ID	rs
RB	)
ID	original
ID	s
AO	=
LB	(
ID	solveUsingRule
ID	p
ID	r
ID	original
ID	s
RB	)
CN	++
LB	(
ID	allSol
ID	p
ID	rs
ID	original
ID	s
RB	)
ID	solveUsingRule
HT	::
ID	Predicate
AR	->
ID	Rule
AR	->
ID	KB
AR	->
ID	Solution
AR	->
LS	[
ID	Solution
RS	]
ID	solveUsingRule
ID	p
LB	(
ID	head
FA	,
ID	body
RB	)
ID	kb
ID	s
AO	=
KW	if
ID	tmpSol
EQ	==
ID	No
KW	then
EL	[]
KW	else
ID	proveBody
LB	(
ID	applySolSubBody
ID	tmpSol
ID	body
RB	)
ID	kb
LB	(
ID	Yes
LB	(
ID	filterTmpVars
ID	subList
RB	)
RB	)
KW	where
LC	{
ID	tmpSol
AO	=
ID	unifyWithHead
ID	p
ID	head
ID	s
SM	;
LB	(
ID	Yes
ID	subList
RB	)
AO	=
ID	tmpSol
RC	}
ID	proveBody
HT	::
ID	Goals
AR	->
ID	KB
AR	->
ID	Solution
AR	->
LS	[
ID	Solution
RS	]
ID	proveBody
EL	[]
WC	_
ID	s
AO	=
LS	[
ID	s
RS	]
ID	proveBody
LB	(
ID	goal
CL	:
ID	goals
RB	)
ID	kb
ID	s
AO	=
ID	concat
LB	(
ID	map
LB	(
ID	proveBody
ID	goals
ID	kb
RB	)
LB	(
ID	allSol
ID	goal
ID	kb
ID	kb
ID	s
RB	)
RB	)
