ID	double
ID	x
AO	=
ID	x
PO	+
ID	x
ID	quadruple
ID	x
AO	=
ID	double
LB	(
ID	double
ID	x
RB	)
ID	twice
ID	x
AO	=
NM	2
MB	*
ID	x
ID	square
ID	x
AO	=
ID	x
MB	*
ID	x
ID	abs
ID	x
AO	=
KW	if
ID	x
GE	>=
NM	0
KW	then
ID	x
KW	else
MO	-
ID	x
ID	signum
ID	x
AO	=
KW	if
ID	x
LT	<
NM	0
KW	then
MO	-
NM	1
KW	else
KW	if
ID	x
EQ	==
NM	0
KW	then
NM	0
KW	else
NM	1
ID	abs1
ID	x
BR	|
ID	x
GE	>=
NM	0
AO	=
ID	x
BR	|
KW	otherwise
AO	=
MO	-
ID	x
ID	signum1
ID	x
BR	|
ID	x
LT	<
NM	0
AO	=
NM	-1
BR	|
ID	x
EQ	==
NM	0
AO	=
NM	0
BR	|
KW	otherwise
AO	=
NM	1
ID	fact
ID	n
AO	=
KW	if
ID	n
EQ	==
NM	0
KW	then
NM	1
KW	else
ID	fact
LB	(
ID	n
NM	-1
RB	)
MB	*
ID	n
ID	fact1
NM	0
AO	=
NM	1
ID	fact1
ID	n
AO	=
ID	fact
LB	(
ID	n
NM	-1
RB	)
MB	*
ID	n
ID	even1
HT	::
DT	Integer
AR	->
DT	Bool
ID	even1
ID	x
BR	|
ID	mod
ID	x
NM	2
EQ	==
NM	0
AO	=
KW	True
BR	|
KW	otherwise
AO	=
KW	False
ID	add
HT	::
DT	Int
AR	->
LB	(
DT	Int
AR	->
DT	Int
RB	)
ID	add
ID	x
ID	y
AO	=
ID	x
PO	+
ID	y
ID	succ
ID	x
AO	=
ID	x
PO	+
NM	1
ID	add1
HT	::
DT	Int
AR	->
DT	Int
AR	->
DT	Int
ID	add1
ID	x
ID	y
AO	=
ID	x
PO	+
ID	y
ID	succ1
AO	=
ID	add1
NM	1
ID	mult
HT	::
DT	Int
AR	->
LB	(
DT	Int
AR	->
LB	(
DT	Int
AR	->
DT	Int
RB	)
RB	)
ID	mult
ID	x
ID	y
ID	z
AO	=
ID	x
MB	*
ID	y
MB	*
ID	z
ID	mult1
HT	::
DT	Int
AR	->
DT	Int
AR	->
DT	Int
AR	->
DT	Int
ID	mult1
ID	x
ID	y
ID	z
AO	=
ID	x
MB	*
ID	y
MB	*
ID	z
KW	data
ID	Fruit
AO	=
ID	Kiwi
BR	|
ID	Apple
BR	|
ID	Banana
ID	isYellow
HT	::
ID	Fruit
AR	->
DT	Bool
ID	isYello
ID	Kiwi
AO	=
KW	False
ID	isYello
ID	Apple
AO	=
KW	False
ID	isYellow
ID	Banana
AO	=
KW	True
KW	type
ID	Point
AO	=
LB	(
DT	Int
FA	,
DT	Int
RB	)
ID	getX
HT	::
ID	Point
AR	->
DT	Int
ID	getX
LB	(
ID	x
FA	,
ID	y
RB	)
AO	=
ID	x
KW	data
ID	Point1
AO	=
ID	Pt
LB	(
DT	Int
FA	,
DT	Int
RB	)
ID	getX1
HT	::
ID	Point1
AR	->
DT	Int
ID	getX1
LB	(
ID	Pt
LB	(
ID	x
FA	,
ID	y
RB	)
RB	)
AO	=
ID	x
KW	data
ID	Nat
AO	=
ID	Zero
BR	|
ID	Succ
ID	Nat
KW	deriving
FR	Show
ID	natPlus
ID	Zero
ID	n
AO	=
ID	n
ID	natPlus
LB	(
ID	Succ
ID	m
RB	)
ID	n
AO	=
ID	Succ
LB	(
ID	natPlus
ID	m
ID	n
RB	)
KW	data
ID	List
ID	a
AO	=
ID	Nil
BR	|
ID	Cons
ID	a
LB	(
ID	List
ID	a
RB	)
KW	deriving
FR	Show
ID	length1
HT	::
ID	List
ID	a
AR	->
DT	Int
ID	length1
ID	Nil
AO	=
NM	0
ID	length1
LB	(
ID	Cons
ID	x
ID	y
RB	)
AO	=
NM	1
PO	+
ID	length1
ID	y
ID	sumAll
EL	[]
AO	=
NM	0
ID	sumAll
LB	(
ID	x
CL	:
ID	xs
RB	)
AO	=
ID	x
PO	+
ID	sumAll
ID	xs
ID	doubleAll
EL	[]
AO	=
EL	[]
ID	doubleAll
LB	(
ID	x
CL	:
ID	xs
RB	)
AO	=
LB	(
ID	x
MB	*
NM	2
RB	)
CL	:
ID	doubleAll
ID	xs
ID	union1
ID	x
ID	y
AO	=
ID	x
CN	++
ID	y
ID	getNth
ID	x
ID	y
AO	=
ID	x
FN	!!
ID	y
ID	length2
EL	[]
AO	=
NM	0
ID	length2
LB	(
ID	x
CL	:
ID	xs
RB	)
AO	=
NM	1
PO	+
ID	length
ID	xs
ID	concat1
EL	[]
AO	=
EL	[]
ID	concat1
LB	(
ID	l
CL	:
ID	ls
RB	)
AO	=
ID	l
CN	++
ID	concat1
ID	ls
ID	head1
EL	[]
AO	=
ID	error
ST	"head1 []"
ID	head1
LB	(
ID	x
CL	:
ID	xs
RB	)
AO	=
ID	x
ID	tail1
EL	[]
AO	=
ID	error
ST	"tail1 []"
ID	tail1
LB	(
ID	x
CL	:
ID	xs
RB	)
AO	=
ID	xs
ID	last1
EL	[]
AO	=
ID	error
ST	"last []"
ID	last1
LS	[
ID	x
RS	]
AO	=
ID	x
ID	last1
LB	(
ID	x
CL	:
ID	xs
RB	)
AO	=
ID	last1
ID	xs
ID	zip1
ID	xs
EL	[]
AO	=
EL	[]
ID	zip1
EL	[]
ID	ys
AO	=
EL	[]
ID	zip1
LB	(
ID	x
CL	:
ID	xs
RB	)
LB	(
ID	y
CL	:
ID	ys
RB	)
AO	=
LB	(
ID	x
FA	,
ID	y
RB	)
CL	:
ID	zip1
ID	xs
ID	ys
ID	unzip1
EL	[]
AO	=
LB	(
EL	[]
FA	,
EL	[]
RB	)
ID	unzip1
LB	(
LB	(
ID	x
FA	,
ID	y
RB	)
CL	:
ID	ps
RB	)
AO	=
LB	(
ID	x
CL	:
ID	l1
FA	,
ID	y
CL	:
ID	l2
RB	)
KW	where
LB	(
ID	l1
FA	,
ID	l2
RB	)
AO	=
ID	unzip1
ID	ps
ID	seq1
ID	x
ID	y
AO	=
LS	[
ID	x
DD	..
ID	y
RS	]
ID	seq2
ID	x
ID	y
AO	=
LS	[
ID	x
FA	,
ID	x
PO	+
NM	2
DD	..
ID	y
RS	]
ID	seqb
ID	x
ID	y
AO	=
LS	[
ID	x
FA	,
ID	x
NM	-1
DD	..
ID	y
RS	]
ID	seqb2
ID	x
ID	y
AO	=
LS	[
ID	x
FA	,
ID	x
NM	-2
DD	..
ID	y
RS	]
ID	seqs
ID	x
ID	y
ID	z
AO	=
LS	[
ID	x
FA	,
ID	x
PO	+
ID	z
DD	..
ID	y
RS	]
ID	seqbs
ID	x
ID	y
ID	z
AO	=
LS	[
ID	x
FA	,
ID	x
MO	-
ID	z
DD	..
ID	y
RS	]
ID	factAll
EL	[]
AO	=
EL	[]
ID	factAll
LB	(
ID	x
CL	:
ID	xs
RB	)
AO	=
ID	fact
ID	x
CL	:
ID	factAll
ID	xs
ID	map1
ID	f
EL	[]
AO	=
EL	[]
ID	map1
ID	f
LB	(
ID	x
CL	:
ID	xs
RB	)
AO	=
LB	(
ID	f
ID	x
RB	)
CL	:
ID	map1
ID	f
ID	xs
ID	factAll1
ID	xs
AO	=
ID	map1
ID	fact
ID	xs
ID	product1
EL	[]
AO	=
NM	1
ID	product1
LB	(
ID	x
CL	:
ID	xs
RB	)
AO	=
ID	x
MB	*
ID	product1
ID	xs
ID	concat2
EL	[]
AO	=
EL	[]
ID	concat2
LB	(
ID	l
CL	:
ID	ls
RB	)
AO	=
ID	l
CN	++
ID	concat2
ID	ls
ID	foldr2
ID	f
ID	e
EL	[]
AO	=
ID	e
ID	foldr2
ID	f
ID	e
LB	(
ID	x
CL	:
ID	xs
RB	)
AO	=
ID	f
ID	x
LB	(
ID	foldr2
ID	f
ID	e
ID	xs
RB	)
ID	product3
ID	list
AO	=
ID	foldr2
LB	(
MB	*
RB	)
NM	1
ID	list
ID	concat3
ID	list
AO	=
ID	foldr2
LB	(
CN	++
RB	)
EL	[]
ID	list
ID	addOnetoList
ID	l
AO	=
ID	map1
LB	(
ID	add1
NM	1
RB	)
ID	l
ID	gt
HT	::
FR	Ord
ID	a
DA	=>
ID	a
AR	->
ID	a
AR	->
ID	a
ID	gt
ID	x
ID	y
AO	=
KW	if
ID	x
LT	<
ID	y
KW	then
ID	y
KW	else
ID	x
